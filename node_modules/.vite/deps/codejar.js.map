{
  "version": 3,
  "sources": ["../../codejar/codejar.js"],
  "sourcesContent": ["const globalWindow = window;\r\nexport function CodeJar(editor, highlight, opt = {}) {\r\n    const options = Object.assign({ tab: '\\t', indentOn: /[({\\[]$/, moveToNewLine: /^[)}\\]]/, spellcheck: false, catchTab: true, preserveIdent: true, addClosing: true, history: true, window: globalWindow }, opt);\r\n    const window = options.window;\r\n    const document = window.document;\r\n    let listeners = [];\r\n    let history = [];\r\n    let at = -1;\r\n    let focus = false;\r\n    let callback;\r\n    let prev; // code content prior keydown event\r\n    editor.setAttribute('contenteditable', 'plaintext-only');\r\n    editor.setAttribute('spellcheck', options.spellcheck ? 'true' : 'false');\r\n    editor.style.outline = 'none';\r\n    editor.style.overflowWrap = 'break-word';\r\n    editor.style.overflowY = 'auto';\r\n    editor.style.whiteSpace = 'pre-wrap';\r\n    let isLegacy = false; // true if plaintext-only is not supported\r\n    highlight(editor);\r\n    if (editor.contentEditable !== 'plaintext-only')\r\n        isLegacy = true;\r\n    if (isLegacy)\r\n        editor.setAttribute('contenteditable', 'true');\r\n    const debounceHighlight = debounce(() => {\r\n        const pos = save();\r\n        highlight(editor, pos);\r\n        restore(pos);\r\n    }, 30);\r\n    let recording = false;\r\n    const shouldRecord = (event) => {\r\n        return !isUndo(event) && !isRedo(event)\r\n            && event.key !== 'Meta'\r\n            && event.key !== 'Control'\r\n            && event.key !== 'Alt'\r\n            && !event.key.startsWith('Arrow');\r\n    };\r\n    const debounceRecordHistory = debounce((event) => {\r\n        if (shouldRecord(event)) {\r\n            recordHistory();\r\n            recording = false;\r\n        }\r\n    }, 300);\r\n    const on = (type, fn) => {\r\n        listeners.push([type, fn]);\r\n        editor.addEventListener(type, fn);\r\n    };\r\n    on('keydown', event => {\r\n        if (event.defaultPrevented)\r\n            return;\r\n        prev = toString();\r\n        if (options.preserveIdent)\r\n            handleNewLine(event);\r\n        else\r\n            legacyNewLineFix(event);\r\n        if (options.catchTab)\r\n            handleTabCharacters(event);\r\n        if (options.addClosing)\r\n            handleSelfClosingCharacters(event);\r\n        if (options.history) {\r\n            handleUndoRedo(event);\r\n            if (shouldRecord(event) && !recording) {\r\n                recordHistory();\r\n                recording = true;\r\n            }\r\n        }\r\n        if (isLegacy && !isCopy(event))\r\n            restore(save());\r\n    });\r\n    on('keyup', event => {\r\n        if (event.defaultPrevented)\r\n            return;\r\n        if (event.isComposing)\r\n            return;\r\n        if (prev !== toString())\r\n            debounceHighlight();\r\n        debounceRecordHistory(event);\r\n        if (callback)\r\n            callback(toString());\r\n    });\r\n    on('focus', _event => {\r\n        focus = true;\r\n    });\r\n    on('blur', _event => {\r\n        focus = false;\r\n    });\r\n    on('paste', event => {\r\n        recordHistory();\r\n        handlePaste(event);\r\n        recordHistory();\r\n        if (callback)\r\n            callback(toString());\r\n    });\r\n    function save() {\r\n        const s = getSelection();\r\n        const pos = { start: 0, end: 0, dir: undefined };\r\n        let { anchorNode, anchorOffset, focusNode, focusOffset } = s;\r\n        if (!anchorNode || !focusNode)\r\n            throw 'error1';\r\n        // If the anchor and focus are the editor element, return either a full\r\n        // highlight or a start/end cursor position depending on the selection\r\n        if (anchorNode === editor && focusNode === editor) {\r\n            pos.start = (anchorOffset > 0 && editor.textContent) ? editor.textContent.length : 0;\r\n            pos.end = (focusOffset > 0 && editor.textContent) ? editor.textContent.length : 0;\r\n            pos.dir = (focusOffset >= anchorOffset) ? '->' : '<-';\r\n            return pos;\r\n        }\r\n        // Selection anchor and focus are expected to be text nodes,\r\n        // so normalize them.\r\n        if (anchorNode.nodeType === Node.ELEMENT_NODE) {\r\n            const node = document.createTextNode('');\r\n            anchorNode.insertBefore(node, anchorNode.childNodes[anchorOffset]);\r\n            anchorNode = node;\r\n            anchorOffset = 0;\r\n        }\r\n        if (focusNode.nodeType === Node.ELEMENT_NODE) {\r\n            const node = document.createTextNode('');\r\n            focusNode.insertBefore(node, focusNode.childNodes[focusOffset]);\r\n            focusNode = node;\r\n            focusOffset = 0;\r\n        }\r\n        visit(editor, el => {\r\n            if (el === anchorNode && el === focusNode) {\r\n                pos.start += anchorOffset;\r\n                pos.end += focusOffset;\r\n                pos.dir = anchorOffset <= focusOffset ? '->' : '<-';\r\n                return 'stop';\r\n            }\r\n            if (el === anchorNode) {\r\n                pos.start += anchorOffset;\r\n                if (!pos.dir) {\r\n                    pos.dir = '->';\r\n                }\r\n                else {\r\n                    return 'stop';\r\n                }\r\n            }\r\n            else if (el === focusNode) {\r\n                pos.end += focusOffset;\r\n                if (!pos.dir) {\r\n                    pos.dir = '<-';\r\n                }\r\n                else {\r\n                    return 'stop';\r\n                }\r\n            }\r\n            if (el.nodeType === Node.TEXT_NODE) {\r\n                if (pos.dir != '->')\r\n                    pos.start += el.nodeValue.length;\r\n                if (pos.dir != '<-')\r\n                    pos.end += el.nodeValue.length;\r\n            }\r\n        });\r\n        // collapse empty text nodes\r\n        editor.normalize();\r\n        return pos;\r\n    }\r\n    function restore(pos) {\r\n        const s = getSelection();\r\n        let startNode, startOffset = 0;\r\n        let endNode, endOffset = 0;\r\n        if (!pos.dir)\r\n            pos.dir = '->';\r\n        if (pos.start < 0)\r\n            pos.start = 0;\r\n        if (pos.end < 0)\r\n            pos.end = 0;\r\n        // Flip start and end if the direction reversed\r\n        if (pos.dir == '<-') {\r\n            const { start, end } = pos;\r\n            pos.start = end;\r\n            pos.end = start;\r\n        }\r\n        let current = 0;\r\n        visit(editor, el => {\r\n            if (el.nodeType !== Node.TEXT_NODE)\r\n                return;\r\n            const len = (el.nodeValue || '').length;\r\n            if (current + len > pos.start) {\r\n                if (!startNode) {\r\n                    startNode = el;\r\n                    startOffset = pos.start - current;\r\n                }\r\n                if (current + len > pos.end) {\r\n                    endNode = el;\r\n                    endOffset = pos.end - current;\r\n                    return 'stop';\r\n                }\r\n            }\r\n            current += len;\r\n        });\r\n        if (!startNode)\r\n            startNode = editor, startOffset = editor.childNodes.length;\r\n        if (!endNode)\r\n            endNode = editor, endOffset = editor.childNodes.length;\r\n        // Flip back the selection\r\n        if (pos.dir == '<-') {\r\n            [startNode, startOffset, endNode, endOffset] = [endNode, endOffset, startNode, startOffset];\r\n        }\r\n        s.setBaseAndExtent(startNode, startOffset, endNode, endOffset);\r\n    }\r\n    function beforeCursor() {\r\n        const s = getSelection();\r\n        const r0 = s.getRangeAt(0);\r\n        const r = document.createRange();\r\n        r.selectNodeContents(editor);\r\n        r.setEnd(r0.startContainer, r0.startOffset);\r\n        return r.toString();\r\n    }\r\n    function afterCursor() {\r\n        const s = getSelection();\r\n        const r0 = s.getRangeAt(0);\r\n        const r = document.createRange();\r\n        r.selectNodeContents(editor);\r\n        r.setStart(r0.endContainer, r0.endOffset);\r\n        return r.toString();\r\n    }\r\n    function handleNewLine(event) {\r\n        if (event.key === 'Enter') {\r\n            const before = beforeCursor();\r\n            const after = afterCursor();\r\n            let [padding] = findPadding(before);\r\n            let newLinePadding = padding;\r\n            // If last symbol is \"{\" ident new line\r\n            if (options.indentOn.test(before)) {\r\n                newLinePadding += options.tab;\r\n            }\r\n            // Preserve padding\r\n            if (newLinePadding.length > 0) {\r\n                preventDefault(event);\r\n                event.stopPropagation();\r\n                insert('\\n' + newLinePadding);\r\n            }\r\n            else {\r\n                legacyNewLineFix(event);\r\n            }\r\n            // Place adjacent \"}\" on next line\r\n            if (newLinePadding !== padding && options.moveToNewLine.test(after)) {\r\n                const pos = save();\r\n                insert('\\n' + padding);\r\n                restore(pos);\r\n            }\r\n        }\r\n    }\r\n    function legacyNewLineFix(event) {\r\n        // Firefox does not support plaintext-only mode\r\n        // and puts <div><br></div> on Enter. Let's help.\r\n        if (isLegacy && event.key === 'Enter') {\r\n            preventDefault(event);\r\n            event.stopPropagation();\r\n            if (afterCursor() == '') {\r\n                insert('\\n ');\r\n                const pos = save();\r\n                pos.start = --pos.end;\r\n                restore(pos);\r\n            }\r\n            else {\r\n                insert('\\n');\r\n            }\r\n        }\r\n    }\r\n    function handleSelfClosingCharacters(event) {\r\n        const open = `([{'\"`;\r\n        const close = `)]}'\"`;\r\n        const codeAfter = afterCursor();\r\n        const codeBefore = beforeCursor();\r\n        const escapeCharacter = codeBefore.substr(codeBefore.length - 1) === '\\\\';\r\n        const charAfter = codeAfter.substr(0, 1);\r\n        if (close.includes(event.key) && !escapeCharacter && charAfter === event.key) {\r\n            // We already have closing char next to cursor.\r\n            // Move one char to right.\r\n            const pos = save();\r\n            preventDefault(event);\r\n            pos.start = ++pos.end;\r\n            restore(pos);\r\n        }\r\n        else if (open.includes(event.key)\r\n            && !escapeCharacter\r\n            && (`\"'`.includes(event.key) || ['', ' ', '\\n'].includes(charAfter))) {\r\n            preventDefault(event);\r\n            const pos = save();\r\n            const wrapText = pos.start == pos.end ? '' : getSelection().toString();\r\n            const text = event.key + wrapText + close[open.indexOf(event.key)];\r\n            insert(text);\r\n            pos.start++;\r\n            pos.end++;\r\n            restore(pos);\r\n        }\r\n    }\r\n    function handleTabCharacters(event) {\r\n        if (event.key === 'Tab') {\r\n            preventDefault(event);\r\n            if (event.shiftKey) {\r\n                const before = beforeCursor();\r\n                let [padding, start,] = findPadding(before);\r\n                if (padding.length > 0) {\r\n                    const pos = save();\r\n                    // Remove full length tab or just remaining padding\r\n                    const len = Math.min(options.tab.length, padding.length);\r\n                    restore({ start, end: start + len });\r\n                    document.execCommand('delete');\r\n                    pos.start -= len;\r\n                    pos.end -= len;\r\n                    restore(pos);\r\n                }\r\n            }\r\n            else {\r\n                insert(options.tab);\r\n            }\r\n        }\r\n    }\r\n    function handleUndoRedo(event) {\r\n        if (isUndo(event)) {\r\n            preventDefault(event);\r\n            at--;\r\n            const record = history[at];\r\n            if (record) {\r\n                editor.innerHTML = record.html;\r\n                restore(record.pos);\r\n            }\r\n            if (at < 0)\r\n                at = 0;\r\n        }\r\n        if (isRedo(event)) {\r\n            preventDefault(event);\r\n            at++;\r\n            const record = history[at];\r\n            if (record) {\r\n                editor.innerHTML = record.html;\r\n                restore(record.pos);\r\n            }\r\n            if (at >= history.length)\r\n                at--;\r\n        }\r\n    }\r\n    function recordHistory() {\r\n        if (!focus)\r\n            return;\r\n        const html = editor.innerHTML;\r\n        const pos = save();\r\n        const lastRecord = history[at];\r\n        if (lastRecord) {\r\n            if (lastRecord.html === html\r\n                && lastRecord.pos.start === pos.start\r\n                && lastRecord.pos.end === pos.end)\r\n                return;\r\n        }\r\n        at++;\r\n        history[at] = { html, pos };\r\n        history.splice(at + 1);\r\n        const maxHistory = 300;\r\n        if (at > maxHistory) {\r\n            at = maxHistory;\r\n            history.splice(0, 1);\r\n        }\r\n    }\r\n    function handlePaste(event) {\r\n        preventDefault(event);\r\n        const text = (event.originalEvent || event)\r\n            .clipboardData\r\n            .getData('text/plain')\r\n            .replace(/\\r/g, '');\r\n        const pos = save();\r\n        insert(text);\r\n        highlight(editor);\r\n        restore({\r\n            start: Math.min(pos.start, pos.end) + text.length,\r\n            end: Math.min(pos.start, pos.end) + text.length,\r\n            dir: '<-',\r\n        });\r\n    }\r\n    function visit(editor, visitor) {\r\n        const queue = [];\r\n        if (editor.firstChild)\r\n            queue.push(editor.firstChild);\r\n        let el = queue.pop();\r\n        while (el) {\r\n            if (visitor(el) === 'stop')\r\n                break;\r\n            if (el.nextSibling)\r\n                queue.push(el.nextSibling);\r\n            if (el.firstChild)\r\n                queue.push(el.firstChild);\r\n            el = queue.pop();\r\n        }\r\n    }\r\n    function isCtrl(event) {\r\n        return event.metaKey || event.ctrlKey;\r\n    }\r\n    function isUndo(event) {\r\n        return isCtrl(event) && !event.shiftKey && getKeyCode(event) === 'Z';\r\n    }\r\n    function isRedo(event) {\r\n        return isCtrl(event) && event.shiftKey && getKeyCode(event) === 'Z';\r\n    }\r\n    function isCopy(event) {\r\n        return isCtrl(event) && getKeyCode(event) === 'C';\r\n    }\r\n    function getKeyCode(event) {\r\n        let key = event.key || event.keyCode || event.which;\r\n        if (!key)\r\n            return undefined;\r\n        return (typeof key === 'string' ? key : String.fromCharCode(key)).toUpperCase();\r\n    }\r\n    function insert(text) {\r\n        text = text\r\n            .replace(/&/g, '&amp;')\r\n            .replace(/</g, '&lt;')\r\n            .replace(/>/g, '&gt;')\r\n            .replace(/\"/g, '&quot;')\r\n            .replace(/'/g, '&#039;');\r\n        document.execCommand('insertHTML', false, text);\r\n    }\r\n    function debounce(cb, wait) {\r\n        let timeout = 0;\r\n        return (...args) => {\r\n            clearTimeout(timeout);\r\n            timeout = window.setTimeout(() => cb(...args), wait);\r\n        };\r\n    }\r\n    function findPadding(text) {\r\n        // Find beginning of previous line.\r\n        let i = text.length - 1;\r\n        while (i >= 0 && text[i] !== '\\n')\r\n            i--;\r\n        i++;\r\n        // Find padding of the line.\r\n        let j = i;\r\n        while (j < text.length && /[ \\t]/.test(text[j]))\r\n            j++;\r\n        return [text.substring(i, j) || '', i, j];\r\n    }\r\n    function toString() {\r\n        return editor.textContent || '';\r\n    }\r\n    function preventDefault(event) {\r\n        event.preventDefault();\r\n    }\r\n    function getSelection() {\r\n        var _a;\r\n        if (((_a = editor.parentNode) === null || _a === void 0 ? void 0 : _a.nodeType) == Node.DOCUMENT_FRAGMENT_NODE) {\r\n            return editor.parentNode.getSelection();\r\n        }\r\n        return window.getSelection();\r\n    }\r\n    return {\r\n        updateOptions(newOptions) {\r\n            Object.assign(options, newOptions);\r\n        },\r\n        updateCode(code) {\r\n            editor.textContent = code;\r\n            highlight(editor);\r\n        },\r\n        onUpdate(cb) {\r\n            callback = cb;\r\n        },\r\n        toString,\r\n        save,\r\n        restore,\r\n        recordHistory,\r\n        destroy() {\r\n            for (let [type, fn] of listeners) {\r\n                editor.removeEventListener(type, fn);\r\n            }\r\n        },\r\n    };\r\n}\r\n"],
  "mappings": "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",
  "names": ["window", "editor"]
}
